/* automatically generated by rust-bindgen 0.69.4 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[doc = "< light area or space between bars"]
pub const zbar_color_e_ZBAR_SPACE: zbar_color_e = 0;
#[doc = "< dark area or colored bar segment"]
pub const zbar_color_e_ZBAR_BAR: zbar_color_e = 1;
#[doc = " \"color\" of element: bar or space."]
pub type zbar_color_e = ::std::os::raw::c_int;
#[doc = " \"color\" of element: bar or space."]
pub use self::zbar_color_e as zbar_color_t;
#[doc = "< no symbol decoded"]
pub const zbar_symbol_type_e_ZBAR_NONE: zbar_symbol_type_e = 0;
#[doc = "< intermediate status"]
pub const zbar_symbol_type_e_ZBAR_PARTIAL: zbar_symbol_type_e = 1;
#[doc = "< GS1 2-digit add-on"]
pub const zbar_symbol_type_e_ZBAR_EAN2: zbar_symbol_type_e = 2;
#[doc = "< GS1 5-digit add-on"]
pub const zbar_symbol_type_e_ZBAR_EAN5: zbar_symbol_type_e = 5;
#[doc = "< EAN-8"]
pub const zbar_symbol_type_e_ZBAR_EAN8: zbar_symbol_type_e = 8;
#[doc = "< UPC-E"]
pub const zbar_symbol_type_e_ZBAR_UPCE: zbar_symbol_type_e = 9;
#[doc = "< ISBN-10 (from EAN-13). @since 0.4"]
pub const zbar_symbol_type_e_ZBAR_ISBN10: zbar_symbol_type_e = 10;
#[doc = "< UPC-A"]
pub const zbar_symbol_type_e_ZBAR_UPCA: zbar_symbol_type_e = 12;
#[doc = "< EAN-13"]
pub const zbar_symbol_type_e_ZBAR_EAN13: zbar_symbol_type_e = 13;
#[doc = "< ISBN-13 (from EAN-13). @since 0.4"]
pub const zbar_symbol_type_e_ZBAR_ISBN13: zbar_symbol_type_e = 14;
#[doc = "< EAN/UPC composite"]
pub const zbar_symbol_type_e_ZBAR_COMPOSITE: zbar_symbol_type_e = 15;
#[doc = "< Interleaved 2 of 5. @since 0.4"]
pub const zbar_symbol_type_e_ZBAR_I25: zbar_symbol_type_e = 25;
#[doc = "< GS1 DataBar (RSS). @since 0.11"]
pub const zbar_symbol_type_e_ZBAR_DATABAR: zbar_symbol_type_e = 34;
#[doc = "< GS1 DataBar Expanded. @since 0.11"]
pub const zbar_symbol_type_e_ZBAR_DATABAR_EXP: zbar_symbol_type_e = 35;
#[doc = "< Codabar. @since 0.11"]
pub const zbar_symbol_type_e_ZBAR_CODABAR: zbar_symbol_type_e = 38;
#[doc = "< Code 39. @since 0.4"]
pub const zbar_symbol_type_e_ZBAR_CODE39: zbar_symbol_type_e = 39;
#[doc = "< PDF417. @since 0.6"]
pub const zbar_symbol_type_e_ZBAR_PDF417: zbar_symbol_type_e = 57;
#[doc = "< QR Code. @since 0.10"]
pub const zbar_symbol_type_e_ZBAR_QRCODE: zbar_symbol_type_e = 64;
#[doc = "< SQ Code. @since 0.20.1"]
pub const zbar_symbol_type_e_ZBAR_SQCODE: zbar_symbol_type_e = 80;
#[doc = "< Code 93. @since 0.11"]
pub const zbar_symbol_type_e_ZBAR_CODE93: zbar_symbol_type_e = 93;
#[doc = "< Code 128"]
pub const zbar_symbol_type_e_ZBAR_CODE128: zbar_symbol_type_e = 128;
#[doc = " mask for base symbol type.\n @deprecated in 0.11, remove this from existing code"]
pub const zbar_symbol_type_e_ZBAR_SYMBOL: zbar_symbol_type_e = 255;
#[doc = " 2-digit add-on flag.\n @deprecated in 0.11, a ::ZBAR_EAN2 component is used for\n 2-digit GS1 add-ons"]
pub const zbar_symbol_type_e_ZBAR_ADDON2: zbar_symbol_type_e = 512;
#[doc = " 5-digit add-on flag.\n @deprecated in 0.11, a ::ZBAR_EAN5 component is used for\n 5-digit GS1 add-ons"]
pub const zbar_symbol_type_e_ZBAR_ADDON5: zbar_symbol_type_e = 1280;
#[doc = " add-on flag mask.\n @deprecated in 0.11, GS1 add-ons are represented using composite\n symbols of type ::ZBAR_COMPOSITE; add-on components use ::ZBAR_EAN2\n or ::ZBAR_EAN5"]
pub const zbar_symbol_type_e_ZBAR_ADDON: zbar_symbol_type_e = 1792;
#[doc = " decoded symbol type."]
pub type zbar_symbol_type_e = ::std::os::raw::c_int;
#[doc = " decoded symbol type."]
pub use self::zbar_symbol_type_e as zbar_symbol_type_t;
#[doc = "< unable to determine orientation"]
pub const zbar_orientation_e_ZBAR_ORIENT_UNKNOWN: zbar_orientation_e = -1;
#[doc = "< upright, read left to right"]
pub const zbar_orientation_e_ZBAR_ORIENT_UP: zbar_orientation_e = 0;
#[doc = "< sideways, read top to bottom"]
pub const zbar_orientation_e_ZBAR_ORIENT_RIGHT: zbar_orientation_e = 1;
#[doc = "< upside-down, read right to left"]
pub const zbar_orientation_e_ZBAR_ORIENT_DOWN: zbar_orientation_e = 2;
#[doc = "< sideways, read bottom to top"]
pub const zbar_orientation_e_ZBAR_ORIENT_LEFT: zbar_orientation_e = 3;
#[doc = " decoded symbol coarse orientation.\n @since 0.11"]
pub type zbar_orientation_e = ::std::os::raw::c_int;
#[doc = " decoded symbol coarse orientation.\n @since 0.11"]
pub use self::zbar_orientation_e as zbar_orientation_t;
#[doc = "< no error"]
pub const zbar_error_e_ZBAR_OK: zbar_error_e = 0;
#[doc = "< out of memory"]
pub const zbar_error_e_ZBAR_ERR_NOMEM: zbar_error_e = 1;
#[doc = "< internal library error"]
pub const zbar_error_e_ZBAR_ERR_INTERNAL: zbar_error_e = 2;
#[doc = "< unsupported request"]
pub const zbar_error_e_ZBAR_ERR_UNSUPPORTED: zbar_error_e = 3;
#[doc = "< invalid request"]
pub const zbar_error_e_ZBAR_ERR_INVALID: zbar_error_e = 4;
#[doc = "< system error"]
pub const zbar_error_e_ZBAR_ERR_SYSTEM: zbar_error_e = 5;
#[doc = "< locking error"]
pub const zbar_error_e_ZBAR_ERR_LOCKING: zbar_error_e = 6;
#[doc = "< all resources busy"]
pub const zbar_error_e_ZBAR_ERR_BUSY: zbar_error_e = 7;
#[doc = "< X11 display error"]
pub const zbar_error_e_ZBAR_ERR_XDISPLAY: zbar_error_e = 8;
#[doc = "< X11 protocol error"]
pub const zbar_error_e_ZBAR_ERR_XPROTO: zbar_error_e = 9;
#[doc = "< output window is closed"]
pub const zbar_error_e_ZBAR_ERR_CLOSED: zbar_error_e = 10;
#[doc = "< windows system error"]
pub const zbar_error_e_ZBAR_ERR_WINAPI: zbar_error_e = 11;
#[doc = "< number of error codes"]
pub const zbar_error_e_ZBAR_ERR_NUM: zbar_error_e = 12;
#[doc = " error codes."]
pub type zbar_error_e = ::std::os::raw::c_int;
#[doc = " error codes."]
pub use self::zbar_error_e as zbar_error_t;
#[doc = "< enable symbology/feature"]
pub const zbar_config_e_ZBAR_CFG_ENABLE: zbar_config_e = 0;
#[doc = "< enable check digit when optional"]
pub const zbar_config_e_ZBAR_CFG_ADD_CHECK: zbar_config_e = 1;
#[doc = "< return check digit when present"]
pub const zbar_config_e_ZBAR_CFG_EMIT_CHECK: zbar_config_e = 2;
#[doc = "< enable full ASCII character set"]
pub const zbar_config_e_ZBAR_CFG_ASCII: zbar_config_e = 3;
#[doc = "< don't convert binary data to text"]
pub const zbar_config_e_ZBAR_CFG_BINARY: zbar_config_e = 4;
#[doc = "< number of boolean decoder configs"]
pub const zbar_config_e_ZBAR_CFG_NUM: zbar_config_e = 5;
#[doc = "< minimum data length for valid decode"]
pub const zbar_config_e_ZBAR_CFG_MIN_LEN: zbar_config_e = 32;
#[doc = "< maximum data length for valid decode"]
pub const zbar_config_e_ZBAR_CFG_MAX_LEN: zbar_config_e = 33;
#[doc = "< required video consistency frames"]
pub const zbar_config_e_ZBAR_CFG_UNCERTAINTY: zbar_config_e = 64;
#[doc = "< enable scanner to collect position data"]
pub const zbar_config_e_ZBAR_CFG_POSITION: zbar_config_e = 128;
#[doc = "< if fails to decode, test inverted"]
pub const zbar_config_e_ZBAR_CFG_TEST_INVERTED: zbar_config_e = 129;
#[doc = "< image scanner vertical scan density"]
pub const zbar_config_e_ZBAR_CFG_X_DENSITY: zbar_config_e = 256;
#[doc = "< image scanner horizontal scan density"]
pub const zbar_config_e_ZBAR_CFG_Y_DENSITY: zbar_config_e = 257;
#[doc = " decoder configuration options.\n @since 0.4"]
pub type zbar_config_e = ::std::os::raw::c_int;
#[doc = " decoder configuration options.\n @since 0.4"]
pub use self::zbar_config_e as zbar_config_t;
#[doc = " barcode tagged as GS1 (EAN.UCC) reserved\n (eg, FNC1 before first data character).\n data may be parsed as a sequence of GS1 AIs"]
pub const zbar_modifier_e_ZBAR_MOD_GS1: zbar_modifier_e = 0;
#[doc = " barcode tagged as AIM reserved\n (eg, FNC1 after first character or digit pair)"]
pub const zbar_modifier_e_ZBAR_MOD_AIM: zbar_modifier_e = 1;
#[doc = " number of modifiers"]
pub const zbar_modifier_e_ZBAR_MOD_NUM: zbar_modifier_e = 2;
#[doc = " decoder symbology modifier flags.\n @since 0.11"]
pub type zbar_modifier_e = ::std::os::raw::c_int;
#[doc = " decoder symbology modifier flags.\n @since 0.11"]
pub use self::zbar_modifier_e as zbar_modifier_t;
pub const video_control_type_e_VIDEO_CNTL_INTEGER: video_control_type_e = 1;
pub const video_control_type_e_VIDEO_CNTL_MENU: video_control_type_e = 2;
pub const video_control_type_e_VIDEO_CNTL_BUTTON: video_control_type_e = 3;
pub const video_control_type_e_VIDEO_CNTL_INTEGER64: video_control_type_e = 4;
pub const video_control_type_e_VIDEO_CNTL_STRING: video_control_type_e = 5;
pub const video_control_type_e_VIDEO_CNTL_BOOLEAN: video_control_type_e = 6;
pub type video_control_type_e = ::std::os::raw::c_int;
pub use self::video_control_type_e as video_control_type_t;
#[doc = " store video control menu\n @param name name of the menu item\n @param val integer value associated with the item"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_control_menu_s {
    pub name: *mut ::std::os::raw::c_char,
    pub value: i64,
}
#[test]
fn bindgen_test_layout_video_control_menu_s() {
    const UNINIT: ::std::mem::MaybeUninit<video_control_menu_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<video_control_menu_s>(),
        16usize,
        concat!("Size of: ", stringify!(video_control_menu_s))
    );
    assert_eq!(
        ::std::mem::align_of::<video_control_menu_s>(),
        8usize,
        concat!("Alignment of ", stringify!(video_control_menu_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(video_control_menu_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(video_control_menu_s),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " store video control menu\n @param name name of the menu item\n @param val integer value associated with the item"]
pub type video_control_menu_t = video_control_menu_s;
#[doc = " store video controls\n @param name name of the control\n @param group name of the control group/class\n @param type type of the control\n @param min minimum value of control (if control is integer)\n @param max maximum value of control (if control is integer)\n @param def default value of control (if control is integer)\n @param step increment steps (if control is integer)\n @param menu menu array\n @param menu_size menu size\n @since 0.20"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_controls_s {
    pub name: *mut ::std::os::raw::c_char,
    pub group: *mut ::std::os::raw::c_char,
    pub type_: video_control_type_t,
    pub min: i64,
    pub max: i64,
    pub def: i64,
    pub step: u64,
    pub menu_size: ::std::os::raw::c_uint,
    pub menu: *mut video_control_menu_t,
    pub next: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_video_controls_s() {
    const UNINIT: ::std::mem::MaybeUninit<video_controls_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<video_controls_s>(),
        80usize,
        concat!("Size of: ", stringify!(video_controls_s))
    );
    assert_eq!(
        ::std::mem::align_of::<video_controls_s>(),
        8usize,
        concat!("Alignment of ", stringify!(video_controls_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(video_controls_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).group) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(video_controls_s),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(video_controls_s),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(video_controls_s),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(video_controls_s),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).def) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(video_controls_s),
            "::",
            stringify!(def)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(video_controls_s),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).menu_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(video_controls_s),
            "::",
            stringify!(menu_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).menu) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(video_controls_s),
            "::",
            stringify!(menu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(video_controls_s),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " store video controls\n @param name name of the control\n @param group name of the control group/class\n @param type type of the control\n @param min minimum value of control (if control is integer)\n @param max maximum value of control (if control is integer)\n @param def default value of control (if control is integer)\n @param step increment steps (if control is integer)\n @param menu menu array\n @param menu_size menu size\n @since 0.20"]
pub type video_controls_t = video_controls_s;
#[doc = " store a video resolution\n @param width width of the video window\n @param height length of the video window\n @param max_fps maximum streaming speed, in frames per second\n @since 0.22"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct video_resolution_s {
    pub width: ::std::os::raw::c_uint,
    pub height: ::std::os::raw::c_uint,
    pub max_fps: f32,
}
#[test]
fn bindgen_test_layout_video_resolution_s() {
    const UNINIT: ::std::mem::MaybeUninit<video_resolution_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<video_resolution_s>(),
        12usize,
        concat!("Size of: ", stringify!(video_resolution_s))
    );
    assert_eq!(
        ::std::mem::align_of::<video_resolution_s>(),
        4usize,
        concat!("Alignment of ", stringify!(video_resolution_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(video_resolution_s),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(video_resolution_s),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_fps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(video_resolution_s),
            "::",
            stringify!(max_fps)
        )
    );
}
extern "C" {
    #[doc = " retrieve runtime library version information.\n @param major set to the running major version (unless NULL)\n @param minor set to the running minor version (unless NULL)\n @returns 0"]
    pub fn zbar_version(
        major: *mut ::std::os::raw::c_uint,
        minor: *mut ::std::os::raw::c_uint,
        patch: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set global library debug level.\n @param verbosity desired debug level.  higher values create more spew"]
    pub fn zbar_set_verbosity(verbosity: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " increase global library debug level.\n eg, for -vvvv"]
    pub fn zbar_increase_verbosity();
}
extern "C" {
    #[doc = " retrieve string name for symbol encoding.\n @param sym symbol type encoding\n @returns the static string name for the specified symbol type,\n or \"UNKNOWN\" if the encoding is not recognized"]
    pub fn zbar_get_symbol_name(sym: zbar_symbol_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " retrieve string name for addon encoding.\n @param sym symbol type encoding\n @returns static string name for any addon, or the empty string\n if no addons were decoded\n @deprecated in 0.11"]
    pub fn zbar_get_addon_name(sym: zbar_symbol_type_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " retrieve string name for configuration setting.\n @param config setting to name\n @returns static string name for config,\n or the empty string if value is not a known config"]
    pub fn zbar_get_config_name(config: zbar_config_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " retrieve string name for modifier.\n @param modifier flag to name\n @returns static string name for modifier,\n or the empty string if the value is not a known flag"]
    pub fn zbar_get_modifier_name(modifier: zbar_modifier_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " retrieve string name for orientation.\n @param orientation orientation encoding\n @returns the static string name for the specified orientation,\n or \"UNKNOWN\" if the orientation is not recognized\n @since 0.11"]
    pub fn zbar_get_orientation_name(
        orientation: zbar_orientation_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " parse a configuration string of the form \"[symbology.]config[=value]\".\n the config must match one of the recognized names.\n the symbology, if present, must match one of the recognized names.\n if symbology is unspecified, it will be set to 0.\n if value is unspecified it will be set to 1.\n @returns 0 if the config is parsed successfully, 1 otherwise\n @since 0.4"]
    pub fn zbar_parse_config(
        config_string: *const ::std::os::raw::c_char,
        symbology: *mut zbar_symbol_type_t,
        config: *mut zbar_config_t,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @internal type unsafe error API (don't use)"]
    pub fn _zbar_error_spew(
        object: *const ::std::os::raw::c_void,
        verbosity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _zbar_error_string(
        object: *const ::std::os::raw::c_void,
        verbosity: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn _zbar_get_error_code(object: *const ::std::os::raw::c_void) -> zbar_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zbar_symbol_s {
    _unused: [u8; 0],
}
pub type zbar_symbol_t = zbar_symbol_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zbar_symbol_set_s {
    _unused: [u8; 0],
}
pub type zbar_symbol_set_t = zbar_symbol_set_s;
extern "C" {
    #[doc = " symbol reference count manipulation.\n increment the reference count when you store a new reference to the\n symbol.  decrement when the reference is no longer used.  do not\n refer to the symbol once the count is decremented and the\n containing image has been recycled or destroyed.\n @note the containing image holds a reference to the symbol, so you\n only need to use this if you keep a symbol after the image has been\n destroyed or reused.\n @since 0.9"]
    pub fn zbar_symbol_ref(symbol: *const zbar_symbol_t, refs: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " retrieve type of decoded symbol.\n @returns the symbol type"]
    pub fn zbar_symbol_get_type(symbol: *const zbar_symbol_t) -> zbar_symbol_type_t;
}
extern "C" {
    #[doc = " retrieve symbology boolean config settings.\n @returns a bitmask indicating which configs were set for the detected\n symbology during decoding.\n @since 0.11"]
    pub fn zbar_symbol_get_configs(symbol: *const zbar_symbol_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " retrieve symbology modifier flag settings.\n @returns a bitmask indicating which characteristics were detected\n during decoding.\n @since 0.11"]
    pub fn zbar_symbol_get_modifiers(symbol: *const zbar_symbol_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " retrieve data decoded from symbol.\n @returns the data string"]
    pub fn zbar_symbol_get_data(symbol: *const zbar_symbol_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " retrieve length of binary data.\n @returns the length of the decoded data"]
    pub fn zbar_symbol_get_data_length(symbol: *const zbar_symbol_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " retrieve a symbol confidence metric.\n @returns an unscaled, relative quantity: larger values are better\n than smaller values, where \"large\" and \"small\" are application\n dependent.\n @note expect the exact definition of this quantity to change as the\n metric is refined.  currently, only the ordered relationship\n between two values is defined and will remain stable in the future\n @since 0.9"]
    pub fn zbar_symbol_get_quality(symbol: *const zbar_symbol_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieve current cache count.  when the cache is enabled for the\n image_scanner this provides inter-frame reliability and redundancy\n information for video streams.\n @returns < 0 if symbol is still uncertain.\n @returns 0 if symbol is newly verified.\n @returns > 0 for duplicate symbols"]
    pub fn zbar_symbol_get_count(symbol: *const zbar_symbol_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieve the number of points in the location polygon.  the\n location polygon defines the image area that the symbol was\n extracted from.\n @returns the number of points in the location polygon\n @note this is currently not a polygon, but the scan locations\n where the symbol was decoded"]
    pub fn zbar_symbol_get_loc_size(symbol: *const zbar_symbol_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " retrieve location polygon x-coordinates.\n points are specified by 0-based index.\n @returns the x-coordinate for a point in the location polygon.\n @returns -1 if index is out of range"]
    pub fn zbar_symbol_get_loc_x(
        symbol: *const zbar_symbol_t,
        index: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieve location polygon y-coordinates.\n points are specified by 0-based index.\n @returns the y-coordinate for a point in the location polygon.\n @returns -1 if index is out of range"]
    pub fn zbar_symbol_get_loc_y(
        symbol: *const zbar_symbol_t,
        index: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieve general orientation of decoded symbol.\n @returns a coarse, axis-aligned indication of symbol orientation or\n ::ZBAR_ORIENT_UNKNOWN if unknown\n @since 0.11"]
    pub fn zbar_symbol_get_orientation(symbol: *const zbar_symbol_t) -> zbar_orientation_t;
}
extern "C" {
    #[doc = " iterate the set to which this symbol belongs (there can be only one).\n @returns the next symbol in the set, or\n @returns NULL when no more results are available"]
    pub fn zbar_symbol_next(symbol: *const zbar_symbol_t) -> *const zbar_symbol_t;
}
extern "C" {
    #[doc = " retrieve components of a composite result.\n @returns the symbol set containing the components\n @returns NULL if the symbol is already a physical symbol\n @since 0.10"]
    pub fn zbar_symbol_get_components(symbol: *const zbar_symbol_t) -> *const zbar_symbol_set_t;
}
extern "C" {
    #[doc = " iterate components of a composite result.\n @returns the first physical component symbol of a composite result\n @returns NULL if the symbol is already a physical symbol\n @since 0.10"]
    pub fn zbar_symbol_first_component(symbol: *const zbar_symbol_t) -> *const zbar_symbol_t;
}
extern "C" {
    #[doc = " print XML symbol element representation to user result buffer.\n @see http://zbar.sourceforge.net/2008/barcode.xsd for the schema.\n @param symbol is the symbol to print\n @param buffer is the inout result pointer, it will be reallocated\n with a larger size if necessary.\n @param buflen is inout length of the result buffer.\n @returns the buffer pointer\n @since 0.6"]
    pub fn zbar_symbol_xml(
        symbol: *const zbar_symbol_t,
        buffer: *mut *mut ::std::os::raw::c_char,
        buflen: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " reference count manipulation.\n increment the reference count when you store a new reference.\n decrement when the reference is no longer used.  do not refer to\n the object any longer once references have been released.\n @since 0.10"]
    pub fn zbar_symbol_set_ref(symbols: *const zbar_symbol_set_t, refs: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " retrieve set size.\n @returns the number of symbols in the set.\n @since 0.10"]
    pub fn zbar_symbol_set_get_size(symbols: *const zbar_symbol_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set iterator.\n @returns the first decoded symbol result in a set\n @returns NULL if the set is empty\n @since 0.10"]
    pub fn zbar_symbol_set_first_symbol(symbols: *const zbar_symbol_set_t) -> *const zbar_symbol_t;
}
extern "C" {
    #[doc = " raw result iterator.\n @returns the first decoded symbol result in a set, *before* filtering\n @returns NULL if the set is empty\n @since 0.11"]
    pub fn zbar_symbol_set_first_unfiltered(
        symbols: *const zbar_symbol_set_t,
    ) -> *const zbar_symbol_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zbar_image_s {
    _unused: [u8; 0],
}
#[doc = " zbar_image_t: opaque image object."]
pub type zbar_image_t = zbar_image_s;
#[doc = " cleanup handler callback function.\n called to free sample data when an image is destroyed."]
pub type zbar_image_cleanup_handler_t =
    ::std::option::Option<unsafe extern "C" fn(image: *mut zbar_image_t)>;
#[doc = " data handler callback function.\n called when decoded symbol results are available for an image"]
pub type zbar_image_data_handler_t = ::std::option::Option<
    unsafe extern "C" fn(image: *mut zbar_image_t, userdata: *const ::std::os::raw::c_void),
>;
extern "C" {
    #[doc = " new image constructor.\n @returns a new image object with uninitialized data and format.\n this image should be destroyed (using zbar_image_destroy()) as\n soon as the application is finished with it"]
    pub fn zbar_image_create() -> *mut zbar_image_t;
}
extern "C" {
    #[doc = " image destructor.  all images created by or returned to the\n application should be destroyed using this function.  when an image\n is destroyed, the associated data cleanup handler will be invoked\n if available\n @note make no assumptions about the image or the data buffer.\n they may not be destroyed/cleaned immediately if the library\n is still using them.  if necessary, use the cleanup handler hook\n to keep track of image data buffers"]
    pub fn zbar_image_destroy(image: *mut zbar_image_t);
}
extern "C" {
    #[doc = " image reference count manipulation.\n increment the reference count when you store a new reference to the\n image.  decrement when the reference is no longer used.  do not\n refer to the image any longer once the count is decremented.\n zbar_image_ref(image, -1) is the same as zbar_image_destroy(image)\n @since 0.5"]
    pub fn zbar_image_ref(image: *mut zbar_image_t, refs: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " image format conversion.  refer to the documentation for supported\n image formats\n @returns a @em new image with the sample data from the original image\n converted to the requested format.  the original image is\n unaffected.\n @note the converted image size may be rounded (up) due to format\n constraints"]
    pub fn zbar_image_convert(
        image: *const zbar_image_t,
        format: ::std::os::raw::c_ulong,
    ) -> *mut zbar_image_t;
}
extern "C" {
    #[doc = " image format conversion with crop/pad.\n if the requested size is larger than the image, the last row/column\n are duplicated to cover the difference.  if the requested size is\n smaller than the image, the extra rows/columns are dropped from the\n right/bottom.\n @returns a @em new image with the sample data from the original\n image converted to the requested format and size.\n @note the image is @em not scaled\n @see zbar_image_convert()\n @since 0.4"]
    pub fn zbar_image_convert_resize(
        image: *const zbar_image_t,
        format: ::std::os::raw::c_ulong,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> *mut zbar_image_t;
}
extern "C" {
    #[doc = " retrieve the image format.\n @returns the fourcc describing the format of the image sample data"]
    pub fn zbar_image_get_format(image: *const zbar_image_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " retrieve a \"sequence\" (page/frame) number associated with this image.\n @since 0.6"]
    pub fn zbar_image_get_sequence(image: *const zbar_image_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " retrieve the width of the image.\n @returns the width in sample columns"]
    pub fn zbar_image_get_width(image: *const zbar_image_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " retrieve the height of the image.\n @returns the height in sample rows"]
    pub fn zbar_image_get_height(image: *const zbar_image_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " retrieve both dimensions of the image.\n fills in the width and height in samples"]
    pub fn zbar_image_get_size(
        image: *const zbar_image_t,
        width: *mut ::std::os::raw::c_uint,
        height: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " retrieve the crop rectangle.\n fills in the image coordinates of the upper left corner and size\n of an axis-aligned rectangular area of the image that will be scanned.\n defaults to the full image\n @since 0.11"]
    pub fn zbar_image_get_crop(
        image: *const zbar_image_t,
        x: *mut ::std::os::raw::c_uint,
        y: *mut ::std::os::raw::c_uint,
        width: *mut ::std::os::raw::c_uint,
        height: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " return the image sample data.  the returned data buffer is only\n valid until zbar_image_destroy() is called"]
    pub fn zbar_image_get_data(image: *const zbar_image_t) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " return the size of image data.\n @since 0.6"]
    pub fn zbar_image_get_data_length(img: *const zbar_image_t) -> ::std::os::raw::c_ulong;
}
extern "C" {
    #[doc = " retrieve the decoded results.\n @returns the (possibly empty) set of decoded symbols\n @returns NULL if the image has not been scanned\n @since 0.10"]
    pub fn zbar_image_get_symbols(image: *const zbar_image_t) -> *const zbar_symbol_set_t;
}
extern "C" {
    #[doc = " associate the specified symbol set with the image, replacing any\n existing results.  use NULL to release the current results from the\n image.\n @see zbar_image_scanner_recycle_image()\n @since 0.10"]
    pub fn zbar_image_set_symbols(image: *mut zbar_image_t, symbols: *const zbar_symbol_set_t);
}
extern "C" {
    #[doc = " image_scanner decode result iterator.\n @returns the first decoded symbol result for an image\n or NULL if no results are available"]
    pub fn zbar_image_first_symbol(image: *const zbar_image_t) -> *const zbar_symbol_t;
}
extern "C" {
    #[doc = " specify the fourcc image format code for image sample data.\n refer to the documentation for supported formats.\n @note this does not convert the data!\n (see zbar_image_convert() for that)"]
    pub fn zbar_image_set_format(image: *mut zbar_image_t, format: ::std::os::raw::c_ulong);
}
extern "C" {
    #[doc = " associate a \"sequence\" (page/frame) number with this image.\n @since 0.6"]
    pub fn zbar_image_set_sequence(image: *mut zbar_image_t, sequence_num: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " specify the pixel size of the image.\n @note this also resets the crop rectangle to the full image\n (0, 0, width, height)\n @note this does not affect the data!"]
    pub fn zbar_image_set_size(
        image: *mut zbar_image_t,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " specify a rectangular region of the image to scan.\n the rectangle will be clipped to the image boundaries.\n defaults to the full image specified by zbar_image_set_size()"]
    pub fn zbar_image_set_crop(
        image: *mut zbar_image_t,
        x: ::std::os::raw::c_uint,
        y: ::std::os::raw::c_uint,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = " specify image sample data.  when image data is no longer needed by\n the library the specific data cleanup handler will be called\n (unless NULL)\n @note application image data will not be modified by the library"]
    pub fn zbar_image_set_data(
        image: *mut zbar_image_t,
        data: *const ::std::os::raw::c_void,
        data_byte_length: ::std::os::raw::c_ulong,
        cleanup_hndlr: zbar_image_cleanup_handler_t,
    );
}
extern "C" {
    #[doc = " built-in cleanup handler.\n passes the image data buffer to free()"]
    pub fn zbar_image_free_data(image: *mut zbar_image_t);
}
extern "C" {
    #[doc = " associate user specified data value with an image.\n @since 0.5"]
    pub fn zbar_image_set_userdata(image: *mut zbar_image_t, userdata: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = " return user specified data value associated with the image.\n @since 0.5"]
    pub fn zbar_image_get_userdata(image: *const zbar_image_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " dump raw image data to a file for debug.\n the data will be prefixed with a 16 byte header consisting of:\n   - 4 bytes uint = 0x676d697a (\"zimg\")\n   - 4 bytes format fourcc\n   - 2 bytes width\n   - 2 bytes height\n   - 4 bytes size of following image data in bytes\n this header can be dumped w/eg:\n @verbatim\nod -Ax -tx1z -N16 -w4 [file]\n@endverbatim\n for some formats the image can be displayed/converted using\n ImageMagick, eg:\n @verbatim\ndisplay -size 640x480+16 [-depth ?] [-sampling-factor ?x?] \\\n{GRAY,RGB,UYVY,YUV}:[file]\n@endverbatim\n\n @param image the image object to dump\n @param filebase base filename, appended with \".XXXX.zimg\" where\n XXXX is the format fourcc\n @returns 0 on success or a system error code on failure"]
    pub fn zbar_image_write(
        image: *const zbar_image_t,
        filebase: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " read back an image in the format written by zbar_image_write()\n @note TBD"]
    pub fn zbar_image_read(filename: *mut ::std::os::raw::c_char) -> *mut zbar_image_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zbar_processor_s {
    _unused: [u8; 0],
}
#[doc = " opaque standalone processor object."]
pub type zbar_processor_t = zbar_processor_s;
extern "C" {
    #[doc = " constructor.\n if threaded is set and threading is available the processor\n will spawn threads where appropriate to avoid blocking and\n improve responsiveness"]
    pub fn zbar_processor_create(threaded: ::std::os::raw::c_int) -> *mut zbar_processor_t;
}
extern "C" {
    #[doc = " destructor.  cleans up all resources associated with the processor"]
    pub fn zbar_processor_destroy(processor: *mut zbar_processor_t);
}
extern "C" {
    #[doc = " (re)initialization.\n opens a video input device and/or prepares to display output"]
    pub fn zbar_processor_init(
        processor: *mut zbar_processor_t,
        video_device: *const ::std::os::raw::c_char,
        enable_display: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " request a preferred size for the video image from the device.\n the request may be adjusted or completely ignored by the driver.\n @note must be called before zbar_processor_init()\n @since 0.6"]
    pub fn zbar_processor_request_size(
        processor: *mut zbar_processor_t,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " request a preferred video driver interface version for\n debug/testing.\n @note must be called before zbar_processor_init()\n @since 0.6"]
    pub fn zbar_processor_request_interface(
        processor: *mut zbar_processor_t,
        version: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " request a preferred video I/O mode for debug/testing.  You will\n get errors if the driver does not support the specified mode.\n @verbatim\n0 = auto-detect\n1 = force I/O using read()\n2 = force memory mapped I/O using mmap()\n3 = force USERPTR I/O (v4l2 only)\n@endverbatim\n @note must be called before zbar_processor_init()\n @since 0.7"]
    pub fn zbar_processor_request_iomode(
        video: *mut zbar_processor_t,
        iomode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " force specific input and output formats for debug/testing.\n @note must be called before zbar_processor_init()"]
    pub fn zbar_processor_force_format(
        processor: *mut zbar_processor_t,
        input_format: ::std::os::raw::c_ulong,
        output_format: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " setup result handler callback.\n the specified function will be called by the processor whenever\n new results are available from the video stream or a static image.\n pass a NULL value to disable callbacks.\n @param processor the object on which to set the handler.\n @param handler the function to call when new results are available.\n @param userdata is set as with zbar_processor_set_userdata().\n @returns the previously registered handler"]
    pub fn zbar_processor_set_data_handler(
        processor: *mut zbar_processor_t,
        handler: zbar_image_data_handler_t,
        userdata: *const ::std::os::raw::c_void,
    ) -> zbar_image_data_handler_t;
}
extern "C" {
    #[doc = " associate user specified data value with the processor.\n @since 0.6"]
    pub fn zbar_processor_set_userdata(
        processor: *mut zbar_processor_t,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " return user specified data value associated with the processor.\n @since 0.6"]
    pub fn zbar_processor_get_userdata(
        processor: *const zbar_processor_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " set config for indicated symbology (0 for all) to specified value.\n @returns 0 for success, non-0 for failure (config does not apply to\n specified symbology, or value out of range)\n @see zbar_decoder_set_config()\n @since 0.4"]
    pub fn zbar_processor_set_config(
        processor: *mut zbar_processor_t,
        symbology: zbar_symbol_type_t,
        config: zbar_config_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set video control value\n @returns 0 for success, non-0 for failure\n @since 0.20\n @see zbar_video_set_control()"]
    pub fn zbar_processor_set_control(
        processor: *mut zbar_processor_t,
        control_name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get video control value\n @returns 0 for success, non-0 for failure\n @since 0.20\n @see zbar_video_get_control()"]
    pub fn zbar_processor_get_control(
        processor: *mut zbar_processor_t,
        control_name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieve the current state of the output window.\n @returns 1 if the output window is currently displayed, 0 if not.\n @returns -1 if an error occurs"]
    pub fn zbar_processor_is_visible(processor: *mut zbar_processor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " show or hide the display window owned by the library.\n the size will be adjusted to the input size"]
    pub fn zbar_processor_set_visible(
        processor: *mut zbar_processor_t,
        visible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " control the processor in free running video mode.\n only works if video input is initialized. if threading is in use,\n scanning will occur in the background, otherwise this is only\n useful wrapping calls to zbar_processor_user_wait(). if the\n library output window is visible, video display will be enabled."]
    pub fn zbar_processor_set_active(
        processor: *mut zbar_processor_t,
        active: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieve decode results for last scanned image/frame.\n @returns the symbol set result container or NULL if no results are\n available\n @note the returned symbol set has its reference count incremented;\n ensure that the count is decremented after use\n @since 0.10"]
    pub fn zbar_processor_get_results(
        processor: *const zbar_processor_t,
    ) -> *const zbar_symbol_set_t;
}
extern "C" {
    #[doc = " wait for input to the display window from the user\n (via mouse or keyboard).\n @returns >0 when input is received, 0 if timeout ms expired\n with no input or -1 in case of an error"]
    pub fn zbar_processor_user_wait(
        processor: *mut zbar_processor_t,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " process from the video stream until a result is available,\n or the timeout (in milliseconds) expires.\n specify a timeout of -1 to scan indefinitely\n (zbar_processor_set_active() may still be used to abort the scan\n from another thread).\n if the library window is visible, video display will be enabled.\n @note that multiple results may still be returned (despite the\n name).\n @returns >0 if symbols were successfully decoded,\n 0 if no symbols were found (ie, the timeout expired)\n or -1 if an error occurs"]
    pub fn zbar_process_one(
        processor: *mut zbar_processor_t,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " process the provided image for barcodes.\n if the library window is visible, the image will be displayed.\n @returns >0 if symbols were successfully decoded,\n 0 if no symbols were found or -1 if an error occurs"]
    pub fn zbar_process_image(
        processor: *mut zbar_processor_t,
        image: *mut zbar_image_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " enable dbus IPC API.\n @returns 0 successful"]
    pub fn zbar_processor_request_dbus(
        proc_: *mut zbar_processor_t,
        req_dbus_enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zbar_video_s {
    _unused: [u8; 0],
}
#[doc = " opaque video object."]
pub type zbar_video_t = zbar_video_s;
extern "C" {
    #[doc = " constructor."]
    pub fn zbar_video_create() -> *mut zbar_video_t;
}
extern "C" {
    #[doc = " destructor."]
    pub fn zbar_video_destroy(video: *mut zbar_video_t);
}
extern "C" {
    #[doc = " open and probe a video device.\n the device specified by platform specific unique name\n (v4l device node path in *nix eg \"/dev/video\",\n  DirectShow DevicePath property in windows).\n @returns 0 if successful or -1 if an error occurs"]
    pub fn zbar_video_open(
        video: *mut zbar_video_t,
        device: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieve file descriptor associated with open *nix video device\n useful for using select()/poll() to tell when new images are\n available (NB v4l2 only!!).\n @returns the file descriptor or -1 if the video device is not open\n or the driver only supports v4l1"]
    pub fn zbar_video_get_fd(video: *const zbar_video_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " request a preferred size for the video image from the device.\n the request may be adjusted or completely ignored by the driver.\n @returns 0 if successful or -1 if the video device is already\n initialized\n @since 0.6"]
    pub fn zbar_video_request_size(
        video: *mut zbar_video_t,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " request a preferred driver interface version for debug/testing.\n @note must be called before zbar_video_open()\n @since 0.6"]
    pub fn zbar_video_request_interface(
        video: *mut zbar_video_t,
        version: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " request a preferred I/O mode for debug/testing.  You will get\n errors if the driver does not support the specified mode.\n @verbatim\n0 = auto-detect\n1 = force I/O using read()\n2 = force memory mapped I/O using mmap()\n3 = force USERPTR I/O (v4l2 only)\n@endverbatim\n @note must be called before zbar_video_open()\n @since 0.7"]
    pub fn zbar_video_request_iomode(
        video: *mut zbar_video_t,
        iomode: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieve current output image width.\n @returns the width or 0 if the video device is not open"]
    pub fn zbar_video_get_width(video: *const zbar_video_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieve current output image height.\n @returns the height or 0 if the video device is not open"]
    pub fn zbar_video_get_height(video: *const zbar_video_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " initialize video using a specific format for debug.\n use zbar_negotiate_format() to automatically select and initialize\n the best available format"]
    pub fn zbar_video_init(
        video: *mut zbar_video_t,
        format: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " start/stop video capture.\n all buffered images are retired when capture is disabled.\n @returns 0 if successful or -1 if an error occurs"]
    pub fn zbar_video_enable(
        video: *mut zbar_video_t,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieve next captured image.  blocks until an image is available.\n @returns NULL if video is not enabled or an error occurs"]
    pub fn zbar_video_next_image(video: *mut zbar_video_t) -> *mut zbar_image_t;
}
extern "C" {
    #[doc = " set video control value (integer).\n @returns 0 for success, non-0 for failure\n @since 0.20\n @see zbar_processor_set_control()"]
    pub fn zbar_video_set_control(
        video: *mut zbar_video_t,
        control_name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get video control value (integer).\n @returns 0 for success, non-0 for failure\n @since 0.20\n @see zbar_processor_get_control()"]
    pub fn zbar_video_get_control(
        video: *mut zbar_video_t,
        control_name: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get available controls from video source\n @returns 0 for success, non-0 for failure\n @since 0.20"]
    pub fn zbar_video_get_controls(
        video: *const zbar_video_t,
        index: ::std::os::raw::c_int,
    ) -> *mut video_controls_s;
}
extern "C" {
    #[doc = " get available video resolutions from video source\n @returns 0 for success, non-0 for failure\n @since 0.22"]
    pub fn zbar_video_get_resolutions(
        vdo: *const zbar_video_t,
        index: ::std::os::raw::c_int,
    ) -> *mut video_resolution_s;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zbar_window_s {
    _unused: [u8; 0],
}
#[doc = " opaque window object."]
pub type zbar_window_t = zbar_window_s;
extern "C" {
    #[doc = " constructor."]
    pub fn zbar_window_create() -> *mut zbar_window_t;
}
extern "C" {
    #[doc = " destructor."]
    pub fn zbar_window_destroy(window: *mut zbar_window_t);
}
extern "C" {
    #[doc = " associate reader with an existing platform window.\n This can be any \"Drawable\" for X Windows or a \"HWND\" for windows.\n input images will be scaled into the output window.\n pass NULL to detach from the resource, further input will be\n ignored"]
    pub fn zbar_window_attach(
        window: *mut zbar_window_t,
        x11_display_w32_hwnd: *mut ::std::os::raw::c_void,
        x11_drawable: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " control content level of the reader overlay.\n the overlay displays graphical data for informational or debug\n purposes.  higher values increase the level of annotation (possibly\n decreasing performance). @verbatim\n0 = disable overlay\n1 = outline decoded symbols (default)\n2 = also track and display input frame rate\n@endverbatim"]
    pub fn zbar_window_set_overlay(window: *mut zbar_window_t, level: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " retrieve current content level of reader overlay.\n @see zbar_window_set_overlay()\n @since 0.10"]
    pub fn zbar_window_get_overlay(window: *const zbar_window_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " draw a new image into the output window."]
    pub fn zbar_window_draw(
        window: *mut zbar_window_t,
        image: *mut zbar_image_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " redraw the last image (exposure handler)."]
    pub fn zbar_window_redraw(window: *mut zbar_window_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " resize the image window (reconfigure handler).\n this does @em not update the contents of the window\n @since 0.3, changed in 0.4 to not redraw window"]
    pub fn zbar_window_resize(
        window: *mut zbar_window_t,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " select a compatible format between video input and output window.\n the selection algorithm attempts to use a format shared by\n video input and window output which is also most useful for\n barcode scanning.  if a format conversion is necessary, it will\n heuristically attempt to minimize the cost of the conversion"]
    pub fn zbar_negotiate_format(
        video: *mut zbar_video_t,
        window: *mut zbar_window_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zbar_image_scanner_s {
    _unused: [u8; 0],
}
#[doc = " opaque image scanner object."]
pub type zbar_image_scanner_t = zbar_image_scanner_s;
extern "C" {
    #[doc = " constructor."]
    pub fn zbar_image_scanner_create() -> *mut zbar_image_scanner_t;
}
extern "C" {
    #[doc = " destructor."]
    pub fn zbar_image_scanner_destroy(scanner: *mut zbar_image_scanner_t);
}
extern "C" {
    #[doc = " setup result handler callback.\n the specified function will be called by the scanner whenever\n new results are available from a decoded image.\n pass a NULL value to disable callbacks.\n @returns the previously registered handler"]
    pub fn zbar_image_scanner_set_data_handler(
        scanner: *mut zbar_image_scanner_t,
        handler: zbar_image_data_handler_t,
        userdata: *const ::std::os::raw::c_void,
    ) -> zbar_image_data_handler_t;
}
extern "C" {
    #[doc = " request sending decoded codes via D-Bus\n @see zbar_processor_parse_config()\n @since 0.21"]
    pub fn zbar_image_scanner_request_dbus(
        scanner: *mut zbar_image_scanner_t,
        req_dbus_enabled: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " set config for indicated symbology (0 for all) to specified value.\n @returns 0 for success, non-0 for failure (config does not apply to\n specified symbology, or value out of range)\n @see zbar_decoder_set_config()\n @since 0.4"]
    pub fn zbar_image_scanner_set_config(
        scanner: *mut zbar_image_scanner_t,
        symbology: zbar_symbol_type_t,
        config: zbar_config_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get config for indicated symbology\n @returns 0 for success, non-0 for failure (config does not apply to\n specified symbology, or value out of range). On success, *value is filled.\n @since 0.22"]
    pub fn zbar_image_scanner_get_config(
        scanner: *mut zbar_image_scanner_t,
        symbology: zbar_symbol_type_t,
        config: zbar_config_t,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " enable or disable the inter-image result cache (default disabled).\n mostly useful for scanning video frames, the cache filters\n duplicate results from consecutive images, while adding some\n consistency checking and hysteresis to the results.\n this interface also clears the cache"]
    pub fn zbar_image_scanner_enable_cache(
        scanner: *mut zbar_image_scanner_t,
        enable: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " remove any previously decoded results from the image scanner and the\n specified image.  somewhat more efficient version of\n zbar_image_set_symbols(image, NULL) which may retain memory for\n subsequent decodes\n @since 0.10"]
    pub fn zbar_image_scanner_recycle_image(
        scanner: *mut zbar_image_scanner_t,
        image: *mut zbar_image_t,
    );
}
extern "C" {
    #[doc = " retrieve decode results for last scanned image.\n @returns the symbol set result container or NULL if no results are\n available\n @note the symbol set does not have its reference count adjusted;\n ensure that the count is incremented if the results may be kept\n after the next image is scanned\n @since 0.10"]
    pub fn zbar_image_scanner_get_results(
        scanner: *const zbar_image_scanner_t,
    ) -> *const zbar_symbol_set_t;
}
extern "C" {
    #[doc = " scan for symbols in provided image.  The image format must be\n \"Y800\" or \"GRAY\".\n @returns >0 if symbols were successfully decoded from the image,\n 0 if no symbols were found or -1 if an error occurs\n @see zbar_image_convert()\n @since 0.9 - changed to only accept grayscale images"]
    pub fn zbar_scan_image(
        scanner: *mut zbar_image_scanner_t,
        image: *mut zbar_image_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zbar_decoder_s {
    _unused: [u8; 0],
}
#[doc = " opaque decoder object."]
pub type zbar_decoder_t = zbar_decoder_s;
#[doc = " decoder data handler callback function.\n called by decoder when new data has just been decoded"]
pub type zbar_decoder_handler_t =
    ::std::option::Option<unsafe extern "C" fn(decoder: *mut zbar_decoder_t)>;
extern "C" {
    #[doc = " constructor."]
    pub fn zbar_decoder_create() -> *mut zbar_decoder_t;
}
extern "C" {
    #[doc = " destructor."]
    pub fn zbar_decoder_destroy(decoder: *mut zbar_decoder_t);
}
extern "C" {
    #[doc = " set config for indicated symbology (0 for all) to specified value.\n @returns 0 for success, non-0 for failure (config does not apply to\n specified symbology, or value out of range)\n @since 0.4"]
    pub fn zbar_decoder_set_config(
        decoder: *mut zbar_decoder_t,
        symbology: zbar_symbol_type_t,
        config: zbar_config_t,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " get config for indicated symbology\n @returns 0 for success, non-0 for failure (config does not apply to\n specified symbology, or value out of range). On success, *value is filled.\n @since 0.22"]
    pub fn zbar_decoder_get_config(
        decoder: *mut zbar_decoder_t,
        symbology: zbar_symbol_type_t,
        config: zbar_config_t,
        value: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " retrieve symbology boolean config settings.\n @returns a bitmask indicating which configs are currently set for the\n specified symbology.\n @since 0.11"]
    pub fn zbar_decoder_get_configs(
        decoder: *const zbar_decoder_t,
        symbology: zbar_symbol_type_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " clear all decoder state.\n any partial symbols are flushed"]
    pub fn zbar_decoder_reset(decoder: *mut zbar_decoder_t);
}
extern "C" {
    #[doc = " mark start of a new scan pass.\n clears any intra-symbol state and resets color to ::ZBAR_SPACE.\n any partially decoded symbol state is retained"]
    pub fn zbar_decoder_new_scan(decoder: *mut zbar_decoder_t);
}
extern "C" {
    #[doc = " process next bar/space width from input stream.\n the width is in arbitrary relative units.  first value of a scan\n is ::ZBAR_SPACE width, alternating from there.\n @returns appropriate symbol type if width completes\n decode of a symbol (data is available for retrieval)\n @returns ::ZBAR_PARTIAL as a hint if part of a symbol was decoded\n @returns ::ZBAR_NONE (0) if no new symbol data is available"]
    pub fn zbar_decode_width(
        decoder: *mut zbar_decoder_t,
        width: ::std::os::raw::c_uint,
    ) -> zbar_symbol_type_t;
}
extern "C" {
    #[doc = " retrieve color of @em next element passed to\n zbar_decode_width()."]
    pub fn zbar_decoder_get_color(decoder: *const zbar_decoder_t) -> zbar_color_t;
}
extern "C" {
    #[doc = " retrieve last decoded data.\n @returns the data string or NULL if no new data available.\n the returned data buffer is owned by library, contents are only\n valid between non-0 return from zbar_decode_width and next library\n call"]
    pub fn zbar_decoder_get_data(decoder: *const zbar_decoder_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " retrieve length of binary data.\n @returns the length of the decoded data or 0 if no new data\n available."]
    pub fn zbar_decoder_get_data_length(decoder: *const zbar_decoder_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " retrieve last decoded symbol type.\n @returns the type or ::ZBAR_NONE if no new data available"]
    pub fn zbar_decoder_get_type(decoder: *const zbar_decoder_t) -> zbar_symbol_type_t;
}
extern "C" {
    #[doc = " retrieve modifier flags for the last decoded symbol.\n @returns a bitmask indicating which characteristics were detected\n during decoding.\n @since 0.11"]
    pub fn zbar_decoder_get_modifiers(decoder: *const zbar_decoder_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " retrieve last decode direction.\n @returns 1 for forward and -1 for reverse\n @returns 0 if the decode direction is unknown or does not apply\n @since 0.11"]
    pub fn zbar_decoder_get_direction(decoder: *const zbar_decoder_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " setup data handler callback.\n the registered function will be called by the decoder\n just before zbar_decode_width() returns a non-zero value.\n pass a NULL value to disable callbacks.\n @returns the previously registered handler"]
    pub fn zbar_decoder_set_handler(
        decoder: *mut zbar_decoder_t,
        handler: zbar_decoder_handler_t,
    ) -> zbar_decoder_handler_t;
}
extern "C" {
    #[doc = " associate user specified data value with the decoder."]
    pub fn zbar_decoder_set_userdata(
        decoder: *mut zbar_decoder_t,
        userdata: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " return user specified data value associated with the decoder."]
    pub fn zbar_decoder_get_userdata(decoder: *const zbar_decoder_t)
        -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct zbar_scanner_s {
    _unused: [u8; 0],
}
#[doc = " opaque scanner object."]
pub type zbar_scanner_t = zbar_scanner_s;
extern "C" {
    #[doc = " constructor.\n if decoder is non-NULL it will be attached to scanner\n and called automatically at each new edge\n current color is initialized to ::ZBAR_SPACE\n (so an initial BAR->SPACE transition may be discarded)"]
    pub fn zbar_scanner_create(decoder: *mut zbar_decoder_t) -> *mut zbar_scanner_t;
}
extern "C" {
    #[doc = " destructor."]
    pub fn zbar_scanner_destroy(scanner: *mut zbar_scanner_t);
}
extern "C" {
    #[doc = " clear all scanner state.\n also resets an associated decoder"]
    pub fn zbar_scanner_reset(scanner: *mut zbar_scanner_t) -> zbar_symbol_type_t;
}
extern "C" {
    #[doc = " mark start of a new scan pass. resets color to ::ZBAR_SPACE.\n also updates an associated decoder.\n @returns any decode results flushed from the pipeline\n @note when not using callback handlers, the return value should\n be checked the same as zbar_scan_y()\n @note call zbar_scanner_flush() at least twice before calling this\n method to ensure no decode results are lost"]
    pub fn zbar_scanner_new_scan(scanner: *mut zbar_scanner_t) -> zbar_symbol_type_t;
}
extern "C" {
    #[doc = " flush scanner processing pipeline.\n forces current scanner position to be a scan boundary.\n call multiple times (max 3) to completely flush decoder.\n @returns any decode/scan results flushed from the pipeline\n @note when not using callback handlers, the return value should\n be checked the same as zbar_scan_y()\n @since 0.9"]
    pub fn zbar_scanner_flush(scanner: *mut zbar_scanner_t) -> zbar_symbol_type_t;
}
extern "C" {
    #[doc = " process next sample intensity value.\n intensity (y) is in arbitrary relative units.\n @returns result of zbar_decode_width() if a decoder is attached,\n otherwise @returns (::ZBAR_PARTIAL) when new edge is detected\n or 0 (::ZBAR_NONE) if no new edge is detected"]
    pub fn zbar_scan_y(
        scanner: *mut zbar_scanner_t,
        y: ::std::os::raw::c_int,
    ) -> zbar_symbol_type_t;
}
extern "C" {
    #[doc = " retrieve last scanned width."]
    pub fn zbar_scanner_get_width(scanner: *const zbar_scanner_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " retrieve sample position of last edge.\n @since 0.10"]
    pub fn zbar_scanner_get_edge(
        scn: *const zbar_scanner_t,
        offset: ::std::os::raw::c_uint,
        prec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " retrieve last scanned color."]
    pub fn zbar_scanner_get_color(scanner: *const zbar_scanner_t) -> zbar_color_t;
}
